# 交易查询

交易查询，或称链码查询。本章节重点分析msp身份认证过程，及查询数据过程。

流程：
1. 客户端，发起链码查询 (client -> peer)
2. peer查出本地数据，响应返回结果给客户端 (peer -> client)


## 1. client发起链码查询
对应命令入口
```bash
peer chaincode query ...
```

1. 程序入口的main函数
(`src/github.com/hyperledger/fabric/peer/main.go:29`)

1. 几层调用后，调用到函数func queryCmd(...)
(`src/github.com/hyperledger/fabric/peer/chaincode/query.go:19`)

1. 在其中，通过函数func InitCmdFactory(...)
初始化对象ChaincodeCmdFactory, 其中包含三个客户端对象pb.EndorserClient, api.PeerDeliverClient, common.BroadcastClient
(`src/github.com/hyperledger/fabric/peer/chaincode/query.go:56`)。

    * 其中，通过函数func common.GetDefaultSignerFnc()获取msp.SigningIdentity签名身份对象
    (`src/github.com/hyperledger/fabric/peer/chaincode/common.go:375`)，
    其实现函数为func GetDefaultSigner()
    (`src/github.com/hyperledger/fabric/peer/common/common.go:159`)。
        
        * 其内部通过func (msp.MSP) GetDefaultSigningIdentity()获取签名身份对象
        (`src/github.com/hyperledger/fabric/peer/common/common.go:160`)。
        * 首先通过函数func loadLocaMSP()做如下事情
        (`src/github.com/hyperledger/fabric/msp/mgmt/mgmt.go:146`)
            1. 获取配置参数如msp类型，其默认为bccspMSP，封装进对象NewOpts中
            具体类型可参考`src/github.com/hyperledger/fabric/msp/msp.go:201`；
            1. 通过函数func New(opts NewOpts)，生成msp实例
            (`src/github.com/hyperledger/fabric/msp/factory.go:56`)
            其中，实际生成逻辑为函数func newBccspMsp(...)，其主要配置了MSP实例继承bccsp.BCCSP的函数，
            如启动、验证身份方法等。
            (`src/github.com/hyperledger/fabric/msp/mspimpl.go:103`)。
            1. bccsp中封装了加密算法, 文件keystore处理等，(#TODO: 值得进一步分析）
            1. 返回msp接口对象，即bccspmsp实例
        
        * 随后，通过bccspmsp获取签名身份对象，
        使用对象方法func (msp *bccspmsp) GetDefaultSigningIdentity()，
        将接口对象bccspmsp.signer返回
        (`src/github.com/hyperledger/fabric/msp/mspimpl.go:255`)，
        其实例类型为signingidentity
        (`src/github.com/hyperledger/fabric/msp/identities.go:226`)。
        signingidentity的实例化过程为，启动命令行时，由函数func InitCmd(...)
        (`src/github.com/hyperledger/fabric/peer/common/common.go:294`),
        到函数func InitCrypto(...)
        (`src/github.com/hyperledger/fabric/peer/common/common.go:324`),
        再到函数func msp.LoadLocalMspWithType(...)，完成实例化。
        (`src/github.com/hyperledger/fabric/peer/common/common.go:143`)。

1. 进一步调用函数func ChaincodeInvokeOrQuery(...)做查询，与invoke基本一致
(`src/github.com/hyperledger/fabric/peer/chaincode/common.go:102`)。

    * 在其中，调用接口方法func (Identity) Serialize()获取交易创建者序列化身份
    (`src/github.com/hyperledger/fabric/peer/chaincode/common.go:438`),
    其实现位于`src/github.com/hyperledger/fabric/msp/identities.go:183`，
    数据结构体由pem公钥证书、mspID组成，然后由protobuf做序列化。
    
    * 随后，通过函数func CreateChaincodeProposalWithTxIDAndTransient(...)，
    生成交易提案
    (`src/github.com/hyperledger/fabric/peer/chaincode/common.go:456`)
    
    * 随后，通过函数func GetSignedProposal(...)，对交易提案使用私钥进行签名
    (`src/github.com/hyperledger/fabric/peer/chaincode/common.go:461`)
    
    * 随后，通过接口方法func (EndorserClient) ProcessProposal(...)，
    将签名的交易提案发送到peer节点，得到返回结果，最后输出。
    (`src/github.com/hyperledger/fabric/peer/chaincode/common.go:467`)
    
## 2. peer节点接受查询请求并处理
对应命令入口
```bash
peer start ...
```

1. peer启动部分请参考[交易发起、排序与写入节点](交易发起、排序与写入节点.md),第二部分

1. 链码查询query与链码调用invoke的处理过程在endorser端完全一致，同样由对象方法
func (e *Endorser) ProcessProposal(...)进行处理，
执行消息完整性与签名等校验、模拟交易执行、返回结果
(`src/github.com/hyperledger/fabric/core/endorser/endorser.go:402`)
(#TODO: 签名校验值得进一步分析)

1. 消息与签名校验，调用函数func ValidateProposalMessage(...)开始
(`src/github.com/hyperledger/fabric/core/endorser/endorser.go:341`)

    *  第一步，进一步调用函数func checkSignatureFromCreator(...)，
    校验交易提案的creator与签名的正确性
    (`src/github.com/hyperledger/fabric/core/common/validation/msgvalidation.go:102`)。
    
    * 在其中，通过接口方法func (Identity) Validate()调用交易创建人的证书校验
    (`src/github.com/hyperledger/fabric/core/common/validation/msgvalidation.go:175`),
    具体实现可参考`src/github.com/hyperledger/fabric/msp/identities.go:103`
    (#TODO:待分析具体实现对应的对象)。

    * 在校验creator过程中，通过对象方法
    func (msp *bccspmsp) getCertificationChainForBCCSPIdentity(...)
    获取系统认可的证书链
    (`src/github.com/hyperledger/fabric/msp/mspimplvalidate.go:24`)。
    在其中，进一步调用func (msp *bccspmsp) getUniqueValidationChain(...),
    (`src/github.com/hyperledger/fabric/msp/mspimpl.go:620`)，
    其中需要调用对象方法func (msp *bccspmsp) getValidityOptsForCert(...)
    获取认可的根证书等验证辅助参数。
    (#TODO: 待分析msp.opts.Roots证书等参数的来源，应主要来自bccspmsp.Setup())
    
    * 随后，使用可信的creator校验交易提案消息签名的正确性,
    调用对象方法func (Identity) Verify(...)
    (`src/github.com/hyperledger/fabric/core/common/validation/msgvalidation.go:183`)
    
    * 第二步，校验提案交易ID，通过函数func CheckProposalTxID(...)
    (`src/github.com/hyperledger/fabric/core/common/validation/msgvalidation.go:120`)；
    校验链码相关信息，通过函数func validateChaincodeProposalMessage(...)
    (`src/github.com/hyperledger/fabric/core/common/validation/msgvalidation.go:138`)。
    
1. 模拟交易执行
    
    *  获取交易模拟器ledger.TxSimulator，账本查询器ledger.HistoryQueryExecutor
    (`src/github.com/hyperledger/fabric/core/endorser/endorser.go:419`)
    
    * 
     