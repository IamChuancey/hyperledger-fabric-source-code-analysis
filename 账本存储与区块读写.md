# 账本存储与区块读写

流程：
1. 发起Transaction Invoke（client->peer) 
2. 执行链码提供背书 (peer->client) 
3. 将已背书Transaction发送排序节点 (client->orderer) 
4. 形成区块，发送各节点commit，写入账本 (orderer->peer)


## 1. 发起Transaction Invoke
对应命令入口
```bash
peer chaincode invoke ...
```

1. 程序入口的main函数
(`src/github.com/hyperledger/fabric/peer/main.go:52`)

1. 调用chaincode.Cmd 
(`src/github.com/hyperledger/fabric/peer/chaincode/chaincode.go:49`)，

1. 进一步调用invokeCmd 
(`src/github.com/hyperledger/fabric/peer/chaincode/invoke.go:19`),

1. 配置参数，配置执行函数 chaincodeInvoke 
(`src/github.com/hyperledger/fabric/peer/chaincode/invoke.go:44`)

1. 在chaincodeInvoke函数中，返回函数chaincodeInvokeOrQuery
（`src/github.com/hyperledger/fabric/peer/chaincode/common.go:92`)

1. 在chaincodeInvokeOrQuery函数中，调用函数ChaincodeInvokeOrQuery执行交易发起逻辑 
(`src/github.com/hyperledger/fabric/peer/chaincode/common.go:424`)  

1. 在ChaincodeInvokeOrQuery函数中，
    * 通过对象方法func (EndorserClient) ProcessProposal，
    发送交易提案对象SignedProposal到peer服务端，获取结果对象ProposalResponse 
    (`src/github.com/hyperledger/fabric/peer/chaincode/common.go:467`)。

    * 校验结果对象ProposalResponse后，通过函数putils.CreateSignedT将提案结果封装为已签名交易，装入common.Envelope
    (`src/github.com/hyperledger/fabric/peer/chaincode/common.go:488`)
    
    * 之后，根据参数决定是否waitForEvent (#TODO,待了解内部逻辑) 
    (`src/github.com/hyperledger/fabric/peer/chaincode/common.go:494`)
   
    * 之后，将已签名交易common.Envelope，通过对象方法func (BroadcastClient) Send，发送到orderer节点。成功后返回ProposalResponse。
    (`src/github.com/hyperledger/fabric/peer/chaincode/common.go:508`)
    
1. 回到chaincodeInvokeOrQuery函数中，将获取的结果对象ProposalResponse做校验，最终打印结果到控制台 
(`src/github.com/hyperledger/fabric/peer/chaincode/common.go:117-130`)


## 2. 服务端处理过程
对应命令入口 
```bash
peer start ... # 启动服务，等待请求并处理  
```

1. 程序入口的main函数
(`src/github.com/hyperledger/fabric/peer/main.go:52`)

1. 调用函数node.Cmd
(`src/github.com/hyperledger/fabric/peer/main.go:45`)

1. 进一步调用startCmd
(`src/github.com/hyperledger/fabric/peer/node/node.go:36`)

1. 进一步执行函数serve，启动服务 
(`src/github.com/hyperledger/fabric/peer/node/start.go:112`)。
    * 在函数serve中，使用接口ACLProvider作为权限控制的抽象，预留权限控制的扩展性 
    (`src/github.com/hyperledger/fabric/peer/node/start.go:147`)
    
    * 通过函数ledgermgmt.Initialize对账本管理器做初始化 (`src/github.com/hyperledger/fabric/peer/node/start.go:161`)，
    具体逻辑位于函数initialize(`src/github.com/hyperledger/fabric/core/ledger/ledgermgmt/ledger_mgmt.go:52`)。
    (#TODO:待熟悉内部)
    
    * 一系列peer服务相关配置处理后，通过执行函数peer.NewPeerServe，得到服务器对象comm.GRPCServer
    (`src/github.com/hyperledger/fabric/peer/node/start.go:200`)。
    
    * comm.GRPCServer对象被用于grpcServer的注册，使用函数pb.RegisterDeliverServer
    (`src/github.com/hyperledger/fabric/peer/node/start.go:227`)
    
    * 通过函数startChaincodeServer，启动链码服务
    (`src/github.com/hyperledger/fabric/peer/node/start.go:230`) 
    (#TODO:待熟悉内部)
    
    * 通过函数startAdminServer，启动管理服务
    (`src/github.com/hyperledger/fabric/peer/node/start.go:235`) 
    (#TODO:待熟悉内部)
    
    * 通过函数pb.RegisterEndorserServer，注册背书服务
    (`src/github.com/hyperledger/fabric/peer/node/start.go:277`)
    
    * 通过函数initGossipService，启动Gossip通信服务。
    (`src/github.com/hyperledger/fabric/peer/node/start.go:282`)
    具体gossip实现在函数gossip.NewGossipService
    (`src/github.com/hyperledger/fabric/gossip/gossip/gossip_impl.go:66`)
    

1. 当接收到proposal请求时





## 3. orderer处理过程
对应命令入口
```bash
orderer start ...
```

1. 程序入口的main函数(`src/github.com/hyperledger/fabric/orderer/main.go:15`)
1. 调用server.Main函数(`src/github.com/hyperledger/fabric/orderer/common/server/main.go:57`)
1. 配置参数，执行函数Start启动服务(`src/github.com/hyperledger/fabric/orderer/common/server/main.go:75`)
1. 在Start中，通过函数NewServer生成实际orderer rpc服务
(`src/github.com/hyperledger/fabric/orderer/common/server/main.go:98`)。随后注册并启动服务。

    * orderer的rpc服务接口抽象为AtomicBroadcastServer
    (`src/github.com/hyperledger/fabric/protos/orderer/ab.pb.go:670`)。
    该接口仅包含Broadcast和Deliver两个方法。Broadcast用于接收客户端交易信息并排序，Deliver用于在成功排序后推送区块给客户端。
    
    * NewServer生成的AtomicBroadcastServer实现类为server
    (`src/github.com/hyperledger/fabric/orderer/common/server/server.go:45`)，
    下文统一称为orderer.server
    
    * 启动模式有start常规模式与benchmark模式。
    (`src/github.com/hyperledger/fabric/orderer/common/server/main.go:107`)
    
1. 当orderer.server接收到请求时，(``)
1. (``)
1. (``)
1. (``)
1. (``)
1. (``)
1. (``)
1. (``)


